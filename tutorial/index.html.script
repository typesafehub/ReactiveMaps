<html>
<head>
    <title>Reactive Maps with Play, Akka and Scala  - Activator Template</title>
</head>
<body>
<div>

    <h2>The world is going reactive</h2>

    <p>
        Not long ago, response times in the seconds were considered appropriate.  Browser refreshes were the norm in web
        applications.  Systems would go down for hours of maintenance, or even be rebooted nightly, and this was ok
        because people only expected the systems to be up during business hours.  Applications didn't have to scale
        because they didn't have big user bases.  And the complexity requirements put on web applications meant that
        typical requests could easily be handled by a thread per request model.
    </p>

    <p>
        Things are changing though.  People expect web applications to react instantly.  They expect them to be up all
        the time, while the applications are moving into the cloud, where failures are not exceptional, but rather are
        the norm, and so applications need to react to failure.  Load on a web application can peak unpredictably, to
        be many orders of magnitude greater than normal, and so applications need to react to load and scale out.  The
        complexity of business requirements means that in order to respond quickly to requests, things must
        be processed in parallel, reacting to events rather than waiting so as to utilise resources as efficiently as
        possible.
    </p>

    <p>
        This application is an example of how to implement the tenets of the
        <a href="http://www.reactivemanifesto.org/" target="_blank">Reactive Manifesto</a>.
    </p>

    <p>
        It uses Play, combined with the latest in client side technologies to implement a reactive user interface.  It
        uses Akka to provide horizontally scalable and resilient message passing and data management.
    </p>

</div>
<div>

    <h2>Browse the app</h2>

    <p>
        Before jumping into the code, let's see the app in action.  Go to the <a href="#run" class="shortcut">Run</a>
        tab, and start the application if it's not already started.  Then visit it at:
        <a href="http://localhost:9000" target="_blank">http://localhost:9000</a>.
    </p>

    <p>
        You will be presented with a screen asking for your email address.  After entering it and submitting, you should
        see a map, and you should be able to find yourself on that map (this may take a short amount of time due to the way
        data flows through summary regions in the system, the further you zoom out the less realtime the app gets).
    </p>

    <p>
        If you zoom in on North Carolina, you should see some bots walking around.  These bots are simulating other
        users, the data used to generate their paths is taken from hiking trail data that was grabbed from
        <a href="http://www.hikewnc.info/" target="_blank">HikeWNC</a>.
    </p>

</div>
<div>

    <h2>System Overview</h2>

    <p>
        The system can be broadly divided into three parts.  The first part is the client side app.  This is written
        in <a href="http://coffeescript.org/" target="_blank">CoffeeScript</a>, and runs in the browser.  The second
        part is the web front end, this is a Play application that serves web requests coming in.  The third part is
        the Akka backend, which manages the distribution of data across backend nodes, and the publishing and
        subscribing of events.
    </p>

    <p>
        In the demo you're seeing now, the Play web front end and the Akka backend are running as one application, but
        in a production scenario, they would be run separately, allowing fine grained control of resources between the
        front and backend.
    </p>

</div>
<div>

    <h2>System Overview - Client</h2>

    <p>
        The client talks to the web front end using
        <a href="http://en.wikipedia.org/wiki/WebSocket" target="_blank">WebSockets</a>:
    </p>

    <img src="tutorial/client-server.svg"/>

    <p>
        All the communication above is fire and forget, after sending a user moved event, the client doesn't need
        anything in response, after sending a viewing area message, the client might get many messages,
        or maybe none at all, depending on whether there are any users in that area, and after the server sends position
        updates, it expects nothing in return from the client.
    </p>

    <p>
        This differs from many traditional client server where clients make a request and expect a response. In a
        reactive application, much of the communication will not be request/response based, because the way reactive
        applications are architected is that data flows to consumers as it becomes available, and consumers of the data
        react to it, they don't ask for it.
    </p>

    <p>
        For this reason, WebSockets makes for a perfect transport for client server communication in a reactive
        application, since it allows events to be passed with low overhead, not needing to wait for a response, and
        facilitates reacting to events from the server.
    </p>

</div>
<div>

    <h2>System Overview - Backend</h2>

    <p>
        Before explaining the backend interface, we need to have a short lesson in geo based systems.  A naive way to
        create the reactive maps application would be to send all data from all users to every connected user.  This
        might work if there are only 10 users connected, or maybe even 100.  At 1000, each user is going to be
        downloading megabytes of updates per second - it is not going to scale.
    </p>

    <p>
        To manage this, we break the earth up into regions.  There are many different ways to do this, but in our app
        we're using the simplest to understand, we flatten the map out into a rectangle, and then divide it into many
        smaller rectangles.  How many rectangles is configurable, but we have defaulted this to 16 million.
        Because the earth is not a reactangle, but is actually a sphere, these rectangles don't all cover the same
        area, at the equator each one is a few kms wide, at the poles, each rectangle is only a few metres wide.  But
        each rectangle is a constant number of degrees in longitude wide, and degrees in latitude high, so transforming
        latitude and longitude coordinates to regions is therefore a straightforward equation.
    </p>

    <p>
        The web front end talks to the backend using Akka clustering:
    </p>

    <img src="tutorial/frontend-region.svg"/>

    <p>
        Actors in an Akka cluster may talk to each other without knowing whether they are on the same node or different
        nodes.  In the above diagram, when a frontend node receives a position update from the client, the region
        responsible for that position may be on the same node, or may be on a different node.  The web frontend doesn't
        need to worry, all it needs to know is which region to send to, and Akka will work out how to get the message
        to the right node.
    </p>
    
    <p>
        Akka distributed PubSub messaging is used to publish location updates to the frontend.  When the web frontend
        gets a new viewing area from the client, it works out which regions cover that viewing area, and then subscribes
        to updates from each of those regions.  Whether those regions are on the same node or on different nodes is
        transparent, Akka ensures that the right messages get to the right subscribers on the right nodes.  When a
        region has a new update to publish, it pushes it to the PubSub manager, which then pushes the messages to the
        right subscribers on the right nodes.
    </p>
    
    <p>
        Finally, regions get summarised into summary regions, and these summary regions are used so that clients that
        are viewing large areas at once aren't consuming too much data.  Lowest level regions and higher level summary
        regions send updates to their higher level summary region, which aggregates and publishes the information.
        When the client requests a viewing area that contains too many regions, it subscribes instead to updates from
        summary regions.
    </p>

</div>
<div>

    <h2>The code - Client side</h2>

    <p>
        Now that we've got a broad overview of the system architecture, let's start looking at the code.  We'll start
        off with tracing the code through from what happens when a users GPS enabled device sends an update.
    </p>

    <p>
        The entry point to this event flow is in
        <a href="#code/app/assets/javascripts/services/gps.coffee" class="shortcut">gps.coffee</a>.  This file contains
        a class for for handling the GPS integration of the app.  It uses the
        <a href="http://www.w3.org/TR/geolocation-API/" target="_blank">HTML5 Geolocation API</a> to watch for location
        updates from the browser.
    </p>

    <p>
        The first thing you'll find in this, and most other CoffeeScript files in this app, is a call to
        <code>define</code>.  This is a <a href="http://requirejs.org/" target="_blank">RequireJS</a> call, used to
        define a module.  RequireJS allows JavaScript to be developed in a modular way, which is important for rich
        client side apps that heavily use JavaScript like this one.  At the bottom of the file you can see a return
        statement returning the <code>Gps</code> class that we've declared, this means anything that imports our module
        will get that class back.
    </p>

    <p>
        The bulk of the code in this file is actually dealing with ensuring that neither too few, nor too many location
        updates are sent to the server.  It ensures that a location update is sent at least every 10 seconds, but no
        more frequently than every 2 seconds.  The most pertinent code that we're interested in now though is the
        <code>navigator.geolocation.watchPosition(...)</code> call, this is the HTML5 Geolocation API call to watch for
        GPS updates, and also the <code>@ws.send(...)</code> call, this sends a <code>user-moved</code> event as JSON
        through the WebSocket, with the users current position.
    </p>

    <p>
        The <code>position</code> field of this event is formatted using the <a href="http://geojson.org/">GeoJSON</a> standard,
        which you'll soon see is used throughout the application.
    </p>

    <p>
        So we can now see how location updates are obtained from the browser.  But where does the WebSocket come from
        that it's getting sent down?  You'll see that the constructor of the <code>Gps</code> class accepts the WebSocket as a
        parameter.  This constructor is called from the
        <a href="#code/app/assets/javascripts/models/mainPage.coffee" class="shortcut">mainPage.coffee</a> module.  In
        this module, you can see that in the <code>define</code> call it declares a few dependencies, one being the
        <code>./gps</code> module that we just looked at.
    </p>

    <p>
        Scroll down to the <code>connect</code> method, and you'll see the following code:
    </p>

    <pre><code>@ws = new WebSocket($("meta[name='websocketurl']").attr("content") + email)</code></pre>

    <p>
        This is the code that creates the WebSocket, and a few lines below that, in the <code>onopen</code> callback,
        you can see where we are passing the WebSocket to the <code>Gps</code> constructor.  The URL for the WebSocket
        is coming from a meta element in the page named <code>websocketurl</code>.
    </p>

    <p>
        Open <a href="#code/app/views/main.scala.html" class="shortcut">main.scala.html</a>.  This is the template
        where that meta element is defined.  The content is a call to Plays reverse router.  Play has a configuration
        file called <a href="#code/conf/routes" class="shortcut">routes</a>, this file contains all the configuration
        for how incoming requests are routed to their corresponding actions in Play.  In addition to providing this
        forward routing, Play also generates a reverse router, that code such as this template can call, and it will
        return the URL that can be used to reach that route.  This means that your path information is kept in one
        place - in your routes file, and everything else in your application can depend on it.
    </p>

    <p>
        In the routes file, you can see that the <code>/stream/:email</code> path is routed to
        <code>controllers.Application.stream</code>, so the reverse router call
        <code>@routes.Application.stream("").webSocketURL()</code> will return us that path.
    </p>

    <p>
        You can read more about routing in Play Framework
        <a href="http://www.playframework.com/documentation/latest/ScalaRouting" target="_blank">here</a>.

    </p>

    <p>
        So now we've seen how the client side portion of the app locates and connects to the WebSocket, and how it
        uses that WebSocket to push location updates to the server.
    </p>

</div>
<div>

    <h2>The code - Web Frontend</h2>

    <p>
        In the <a href="#code/conf/routes" class="shortcut">routes</a> file, we saw how the WebSocket route was
        defined, and how it gets routed to the <code>controllers.Application.stream</code> method.  Let's open that
        class now, <a href="#code/app/controllers/Application.scala" class="shortcut">Application.scala</a>.
    </p>

    <p>
        Looking at the <code>stream</code> method, the first thing to notice is that it is declared to be a WebSocket
        action that works with <code>ClientEvent</code> messages.  These messages are defined in
        <a href="#code/app/actors/ClientConnection.scala" class="shortcut">ClientConnection.scala</a>, we can see our
        three types of messages there, <code>UserMoved</code>, <code>ViewingArea</code> and <code>UserPositions</code>.
    </p>

    <p>
        Below the declaration of the message types, we can see formats for serialising these events to and from JSON,
        and for formatting the WebSocket frames.  We won't go into too much detail here, you can read more about Play's
        JSON support <a href="http://www.playframework.com/documentation/latest/ScalaJson" target="_blank">here</a>.
    </p>

    <p>
        You can see back in <a href="#code/app/controllers/Application.scala" class="shortcut">Application.scala</a>
        that we have told Play to use an actor to handle the WebSocket.  This means our deserialized
        <code>ClientEvent</code> messages are sent to this actor, while when this actor sends <code>ClientEvent</code>
        messages to the passed in upstream actor, these messages will be serialized and sent over the WebSocket
        to the client.
    </p>

    <p>
        Back in  <a href="#code/app/actors/ClientConnection.scala" class="shortcut">ClientConnection.scala</a>, beneath
        the event message types, you will find the actual actor that handles the client connection.  The receive method
        shows the handling of the different message types that this actor will receive.  We'll focus on just on of these
        message types.
    </p>

    <p>
        Each time a <code>UserMoved</code> event is received, it's translated to a <code>UserPosition</code> object,
        and sent to the <a href="#code/app/actors/RegionManagerClient.scala" class="shortcut">RegionManagerClient</a>.
        This class is responsible for sending user position updates to the right node for the region that that position
        lives in.  You can see in that class that the first thing it does is look up the regionId, and then it creates
        a <code>UserPositionUpdate</code> message, and sends that message to a router.
    </p>

    <p>
        But how does that router get it to the right node?  The configuration for that router can be found in
        <a href="#code/conf/application.conf" class="shortcut">application.conf</a>.  Scrolling down to the
        configuration in the <code>akka</code> section, you'll see this:
    </p>
    
    <pre><code>/regionManagerClient/router {
  router = consistent-hashing
  nr-of-instances = 1000
  cluster {
    enabled = on
    routees-path = "/user/regionManager"
    allow-local-routees = on
    use-role = "backend-region"
  }
}</code></pre>

    <p>
        The routing to the node responsible for a region is done with a cluster aware 
        <a href="http://en.wikipedia.org/wiki/Consistent_hashing" target="_blank">consistent hashing</a>
        router. The region identifier is used as key for the consistent hashing. This means that updates
        for a region is routed to the backend node responsible for that region. When the number of nodes in
        the cluster changes the responsibility for a region may change. In this application the state of the
        regions don't have to be migrated when this happens. Updates for some regions are routed to a new 
        backend node and old data will expire. For a short period the region points (counts of users) might
        be slightly inaccurate, but that is acceptable for this application.       
    </p>
    
    <p>
        The hash code used to route messages is specified by the <code>ConsistentHashable</code> interface, you can see
        that the <a href="#code/app/backend/RegionManager.scala" class="shortcut">UpdateUserPosition</a> message
        implements this interface, and defines the hash key to be the region ID that the update is for.
    </p>
    
    <p>
        If you're interested in learning the full details of Akka routing and how to configure it, you can read about
        <a href="http://doc.akka.io/docs/akka/2.2.3/scala/routing.html" target="_blank">Routing</a> and 
        <a href="http://doc.akka.io/docs/akka/2.2.3/scala/cluster-usage.html#Cluster_Aware_Routers" target="_blank">
        Cluster Aware Routers</a> in the Akka documentation.
    </p>

    

</div>
<div>

    <h2>The code - Backend</h2>

    <p>
        We've seen how the web frontend receives GPS user position events and then routes them to the right backend
        node in the Akka cluster.  Now let's find out what happens with the events when it reaches the backend node.
    </p>

    <p>
        In the configuration for the router that we saw before, we could see this config item defined:
    </p>

    <pre><code>routees-path = "/user/regionManager"</code></pre>

    <p>
        <code>/user</code> is the namespace for all user defined actors (as opposed to actors defined by the system
        itself), so this says that the messages get sent to a user defined actor called <code>regionManager</code>,
        which is implemented by the <a href="#code/app/backend/RegionManager.scala" class="shortcut">RegionManager</a>
        class.
    </p>

    <p>
        The region manager is responsible for managing all the regions that belong on that node.  If it gets some data
        for a region, and an actor for that region doesn't exist yet, it creates it.  Once it has ensured that an actor
        exists for that region, then it sends the user position to that region.
    </p>

    <p>
        The actor class that represents a region is called
        <a href="#code/app/backend/Region.scala" class="shortcut">Region</a>.  This class has a map called
        <code>activeUsers</code>, and when it receives the user position, it adds that users position to the map.
    </p>

</div>

<div>

    <h2>The code - Subscriptions between frontend and backend</h2>

    <p>
       A client displays a section of the map, which is decorated with live markers of other users in that area.
       How are those user positions published to the client?
    </p>
    
    <p>
       When the user zooms or changes map position the client sends a 
       <a href="#code/app/models/client/ClientEvents.scala" class="shortcut">ViewingArea</a> event to the server, which
       ends up in <a href="#code/app/actors/PositionSubscriber.scala" class="shortcut">PositionSubscriber</a> via
       the <a href="#code/app/controllers/Application.scala" class="shortcut">controller</a>.
       The PositionSubscriber works out which regions cover that viewing area, and then subscribes to updates from
       each of those regions.
    </p>
    
    <p>
       The published updates of user positions comes from the backend <a href="#code/app/backend/Region.scala" class="shortcut">Region</a>
       actors. The thing that ties the publisher and subscriber together is the named topic, which in this case is
       the region id.
    </p>
    
    <p>
       In a similar way the PositionSubscriber may decide to subscribe to summary regions, and then the published 
       region points comes from the <a href="#code/app/backend/SummaryRegion.scala" class="shortcut">SummaryRegion</a>
       actors.
    </p>

    <p>
       The <a href="http://doc.akka.io/docs/akka/2.3-M1/contrib/distributed-pub-sub.html" target="_blank">publish/subscribe</a>
       mechanism in Akka is a registry of subscribers that is replicated to members in the cluster. 
       There is no central hub or broker. When publishing a message to a named topic it sends the message to nodes with
       subscribers of that topic, and then delivers the message to all subscribing actors on that node. The message is sent
       over the wire only once per node that has at least one subscriber of the topic. The decoupling of publisher and
       subscriber makes it easy to add and remove nodes in the cluster as needed.
    </p>
    
    <p>
      Changes of subscribers are disseminated in a scalable way to other nodes with a gossip protocol. The registry is
      eventually consistent, i.e. changes are not immediately visible at other nodes, but typically they will be fully
      replicated to all other nodes after a few seconds.
    </p>
    
</div>

<div>

    <h2>The code - Summary</h2>

    <p>
        At this stage of the tutorial, we've seen:
    </p>

    <ul>
        <li>How the browser gets the users position from their GPS enabled device</li>
        <li>How the browser sends the users position to the web front end via WebSockets</li>
        <li>How the WebSocket is routed to the corresponding action</li>
        <li>How the WebSocket action sends the users position to an Akka router</li>
        <li>How the Akka router routes the users position to the correct node for the region in the Akka cluster</li>
        <li>How the node receives the users position and sends it to the right actor that manages that position</li>
        <li>How the backend nodes publishes updates to frontend subscribers</li>
    </ul>

    <p>
        And now for something completely different.
    </p>

</div>

<div>
    <h2>Add more nodes</h2>
    
    <p>
      So far you are <a href="#run" class="shortcut">running</a> the application in one single JVM, hosting both frontend
      and backend. Let's try to add more backend and frontend nodes to the cluster.
    </p>
    
    <p>
      Open a terminal and change directory to the root directory of the reactive-maps application. Start a backend node
      with the following command (on one line):
    </p>
    <pre><code>
    &lt;path to activator dir&gt;/activator 
      -Dakka.remote.netty.tcp.port=0 
      -Dakka.cluster.roles.1=backend-region 
      "run-main backend.Main"
    </code></pre>
    
    <p>
      This runs the <a href="#code/app/backend/Main.scala" class="shortcut">backend.Main</a> class and
      overrides the configuration to bind Akka remoting to a random available port and use the "backend-region"
      cluster role for this node.
    </p> 
    
    <p>
      If you take a look at the log in <a href="#run" class="shortcut">Run</a> you can see that the new node
      joined the cluster. The new node knows how to join the cluster because the first node running on port 2552
      is configured as initial contact point in the 'seed-nodes' property in the 
      <a href="#code/conf/application.conf" class="shortcut">application.conf</a>. 
      You can read more about Akka Clustering in the
      <a href="http://doc.akka.io/docs/akka/2.2.3/scala/cluster-usage.html" target="_blank">documentation</a>.  
    </p>
    
    <p>
      You can repeat the command in new terminal windows to add more backend nodes.
    </p>
    
    <p>
      You can also add more simulated users with the following command (on one line):
    </p>
    <pre><code>
    &lt;path to activator dir&gt;/activator 
      -Dakka.remote.netty.tcp.port=0 
      -Dakka.cluster.roles.1=frontend 
      -DreactiveMaps.bots.totalNumberOfBots=500 
      "run-main backend.Main"		
	</code></pre>
	
	<p>
	  The following command (on one line) will start another frontend node listening on HTTP port 9001: 
	</p>
	<pre><code>
    &lt;path to activator dir&gt;/activator 
      -Dhttp.port=9001
      -Dakka.remote.netty.tcp.port=0
      -Dakka.cluster.roles.1=frontend 
      run
    </code></pre>
    <p>
      Try the added frontend in a new browser window: <a href="http://localhost:9001" target="_blank">http://localhost:9001</a>
    </p>
    
</div>

<div>
    <h2>Adding a new feature</h2>

    <p>
        Now that we've had a detailed look at some of the system, let's try and add a new feature. Until now, our view
        of the data has been region based - all data is associated with and stored in an actor for a region.  This
        allows us to shard regions over multiple nodes, allowing efficient access to the data by node.
    </p>

    <p>
        We're going to add functionality that is user based.  We'll use exactly the same methods for scaling as for the
        region based data, so we can see how to build such a system from scratch.
    </p>

    <p>
        We'll start off with a simple implementation that only works when there is one node, implementing first the
        backend, then the client side.  Then we'll demonstrate how this implementation can be scaled out to shard the
        data across many nodes.  Finally we'll show some techniques for ensuring data consistency when nodes are
        introduced into or removed from the cluster.
    </p>

    <p>
        The new feature that we'll add is tracking the distance that a user has travelled.  We'll make the client
        fetch this data when a user clicks on a marker.
    </p>

</div>

<div>
    <h2>Handling the maths</h2>

    <p>
        The first thing we need to do is add a function for calculating the distance between two points.  There are
        many such formulas that can be used to do this, but a simple general purpose one which will suit our purposes
        is called the <a href="http://www.movable-type.co.uk/scripts/latlong.html" target="_blank">haversine</a>
        formula.
    </p>

    <p>
        Let's create a new method called <code>distanceBetweenTwoPoints</code> in
        <code>GeoFunctions</code>:
    </p>

<<app/backend/GeoFunctions.scala>>=
186a
  def distanceBetweenPoints(pointA: LatLng, pointB: LatLng): Double = {
    import Math._
    // Setup the inputs to the formula
    val R = 6371009d // average radius of the earth in metres
    val dLat = toRadians(pointB.lat - pointA.lat)
    val dLng = toRadians(pointB.lng - pointA.lng)
    val latA = toRadians(pointA.lat)
    val latB = toRadians(pointB.lat)

    // The actual haversine formula. a and c are well known value names in the formula.
    val a = sin(dLat / 2) * sin(dLat / 2) +
    sin(dLng / 2) * sin(dLng / 2) * cos(latA) * cos(latB)
    val c = 2 * atan2(sqrt(a), sqrt(1 - a))
    val distance = R * c

    distance
  }
.
@

@@ sbt compile

</div>

<div>
    <h2>User meta data register</h2>

    <p>
        The first thing we need to implement is a user meta data register.  As a first implementation, we'll write one
        actor that will store all user meta data, we'll call it <code>UserMetaData</code>.  Create a new file called
        <code>app/backend/UserMetaData.scala</code> now, and start off by adding the following:
    </p>

<<app/backend/UserMetaData.scala>>=
0a
package backend

  import akka.actor.{Props, Actor}
  import play.extras.geojson.LatLng

  object UserMetaData {
    case class GetUser(id: String)
    case class User(id: String, distance: Double)
    case class UpdateUserPosition(id: String, position: LatLng)

    val props = Props[UserMetaData]
}
.
@

    <p>
        Some of the imports are unused for now, but the important thing to see here is the message types we've defined.
        This actor will receive <code>UpdateUserPosition</code> messages to update the user position, and will receive
        <code>GetUser</code> messages, and send back <code>User</code> messages to the sender.
    </p>

    <p>
        Now implement the actor itself:
    </p>

<<app/backend/UserMetaData.scala>>=
12a
class UserMetaData extends Actor {

  import UserMetaData._

  val settings = Settings(context.system)

  var users = Map.empty[String, (LatLng, Double)]

  def receive = {
  }
}
.
@

    <p>
        Our actor depends on the settings (which provides the <code>GeoFunctions</code> class we already edited), and
        has a map that maps the userId to a tuple of the last position the user was seen at, and the distance they've
        travelled. We'll now implement handling the <code>GetUser</code> message in the <code>receive</code> method:
    </p>

<<app/backend/UserMetaData.scala>>=
21a
    case GetUser(id) =>
      users.get(id) match {
        case Some((_, distance)) => sender ! User(id, distance)
        case None => sender ! User(id, 0)
      }
.
@

    <p>
        You can see that if the user wasn't found, we just return 0.  Now implement handling the
        <code>UpdateUserPosition</code> message:
    </p>

<<app/backend/UserMetaData.scala>>=
27i
    case UpdateUserPosition(id, position) =>
      val distance = users.get(id) match {
        case Some((lastPosition, lastDistance)) =>
          lastDistance + settings.GeoFunctions.distanceBetweenPoints(lastPosition, position)
        case None => 0
      }

      users += (id -> (position, distance))
.
@

@@ sbt compile

    <p>
        You can see here we're using the <code>distanceBetweenPoints</code> method we implemented earlier, updating the
        distance if we have a last position to compare it to, and updating the map with the new user data.
    </p>

</div>

<div>
    <h2>Send user position updates</h2>

    <p>
        Now we need to implement the code that sends the user position updates to this actor.  This is a little tedious
        because there a two things that will do this, the web client, and the bots.  We'll start with the web client.
    </p>

    <p>
        The web client is initialised by a Play plugin called <code>Actors</code>.  In this class, add a
        new <code>lazy val</code> to initialise the user meta data actor:
    </p>

<<app/actors/Actors.scala>>=
46a
  private lazy val userMetaData = system.actorOf(UserMetaData.props, "userMetaData")
.
@

    <p>
        Now provide access to this in the <code>Actors</code> object in the same way that
        <code>regionManagerClient</code> is made accessible:
    </p>

<<app/actors/Actors.scala>>=
20a
  def userMetaData(implicit app: Application) = actors.userMetaData
.
@

    <p>
        You may need to add imports to the class to import the <code>backend.UserMetaData</code> class.
    </p>

    <p>
        The class that will ultimately use this actor is the
        <code>ClientConnection.scala</code> actor.  Open it,
        and modify the constructor of <code>ClientConnection</code> to accept it as a parameter:
    </p>

<<app/actors/ClientConnection.scala>>=
104c
class ClientConnection(email: String, upstream: ActorRef, regionManagerClient: ActorRef,
  userMetaData: ActorRef) extends Actor {
.
@

    <p>
        Now when the client sends a <code>UserMoved</code> message through the web socket, in addition to sending a
        message to the <code>regionManagerClient</code>, we also want to update the user meta data:
    </p>

<<app/actors/ClientConnection.scala>>=
9a
import backend.UserMetaData.UpdateUserPosition
.
116a
      userMetaData ! UpdateUserPosition(email, point.coordinates)
.
@

    <p>
        Since we added a constructor parameter to the <code>ClientConnection</code> actor, we also need to update its
        <code>props</code> method on the companion object to also accept and pass the user meta data actor:
    </p>

<<app/actors/ClientConnection.scala>>=
13,16c
  def props(email: String, upstream: ActorRef, regionManagerClient: ActorRef,
      userMetaData: ActorRef): Props = {
    Props(new ClientConnection(email, upstream, regionManagerClient, userMetaData))
  }
.
@

    <p>
        And finally, we need to pass the actor in to the place that uses this, the
        <code>Application</code> controller, using the
        <code>userMetaData</code> method on <code>Actors</code> that we just wrote:
    </p>

<<app/controllers/Application.scala>>=
20,22c
  def stream(email: String) = WebSocketActor.actorOf[ClientEvent] { _ => upstream =>
    ClientConnection.props(email, upstream, Actors.regionManagerClient, Actors.userMetaData)
  }
.
@

@@ sbt compile

    <p>
        The web front end is set to go, but the bots also need to be updated.  As with <code>ClientConnection</code>,
        add a constructor parameter for the user meta data to <code>GeoJsonBot.scala</code>:
    </p>

<<app/actors/GeoJsonBot.scala>>=
23,24c
class GeoJsonBot(trail: LineString[LatLng], offset: (Double, Double), userId: String,
  regionManagerClient: ActorRef, userMetaData: ActorRef) extends Actor {
.
@

    <p>
        And immediately after the bot sends a position update to the <code>regionManagerClient</code>, make it also
        send one to <code>userMetaData</code>:
    </p>

<<app/actors/GeoJsonBot.scala>>=
10a
import backend.UserMetaData.UpdateUserPosition
.
50a
      userMetaData ! UpdateUserPosition(userId, userPos.position)
.
@

    <p>
        Update the props method:
    </p>

<<app/actors/GeoJsonBot.scala>>=
14,15c
  def props(trail: LineString[LatLng], offset: (Double, Double), userId: String, regionManagerClient: ActorRef,
      userMetaData: ActorRef): Props =
    Props(classOf[GeoJsonBot], trail, offset, userId, regionManagerClient, userMetaData)
.
@

    <p>
        Now this is called by <code>BotManager</code>, modify the props method, constructor parameter and the
        the call that creates the bot:
    </p>

<<app/backend/BotManager.scala>>=
16,17c
  def props(regionManagerClient: ActorRef, userMetaData: ActorRef, data: Seq[URL]): Props =
    Props(classOf[BotManager], regionManagerClient, userMetaData, data)
.
25c
class BotManager(regionManagerClient: ActorRef, userMetaData: ActorRef, data: Seq[URL]) extends Actor {
.
58c
                    context.actorOf(GeoJsonBot.props(route, offset, userId, regionManagerClient, userMetaData))
.
@

    <p>
        <code>BotManager</code> is initialised in two places, once in the web front end by Play in the
        <code>Actors</code> class, so update that to pass the <code>userMetaData</code>:
    </p>

<<app/actors/Actors.scala>>=
43c
      system.actorOf(BotManager.props(regionManagerClient, userMetaData, findUrls(1)))
.
@

    <p>
        And finally, we need to update the <code>Main</code> class, this
        is used when running a non Play node in the cluster.  Initialise the <code>UserMetaData</code> actor after
        creating <code>RegionManagerClient</code>:
    </p>

<<app/backend/Main.scala>>=
30a
      val userMetaData = system.actorOf(UserMetaData.props, "userMetaData")
.
@

    <p>
        Now pass the actor to the <code>BotsManager</code> props methed:
    </p>

<<app/backend/Main.scala>>=
38c
      system.actorOf(BotManager.props(regionManagerClient, userMetaData, findUrls(1)))
.
@

@@ sbt compile

</div>

<div>
    <h2>Exposing user data to the web</h2>

    <p>
        The users distance is going to be requested by the user on an as needed basis.  Since the action is triggered
        by the user and the user expects a response, it makes sense in this case to use a simple HTTP request to get
        the data.  So we're going to write a Play action to get the user meta data.
    </p>

    <p>
        Create a new Scala class called <code>controllers.UserController</code>:
    </p>

<<app/controllers/UserController.scala>>=
0a
package controllers

import akka.pattern.{AskTimeoutException, ask}
import akka.util.Timeout

import play.api.mvc._
import play.api.libs.concurrent.Execution.Implicits._
import play.api.libs.json.Json
import play.api.Play.current

import scala.concurrent.duration._

import actors.Actors
import backend.UserMetaData._

object UserController extends Controller {

}
.
@

    <p>
        There are quite a number of imports here, but don't be put off!  The first thing we will do is define the
        return format for the user meta data.  We're going to return JSON, so we need something to convert instances of
        <code>User</code> into JSON.  We can do this by implementing a JSON <code>Writes</code> for <code>User</code>.
        Play's JSON API provides a handy macro that does this for you at compile time, so you can have type safe JSON
        converters with a minimum of code.  Create this writes instance in the <code>UserController</code> object:
    </p>

<<app/controllers/UserController.scala>>=
17a
implicit val userWrites = Json.writes[User]
.
@

    <p>
        Since it is declared to be implicit, it will be used whenever we call a method that requires an implicit writes
        for <code>User</code>, which the <code>Json.toJson</code> method does in the next block of code that we'll
        write:
    </p>

<<app/controllers/UserController.scala>>=
18a
  def get(id: String) = Action.async {
    implicit val timeout = Timeout(2.seconds)

    (Actors.userMetaData ? GetUser(id))
      .mapTo[User]
      .map { user =>
        Ok(Json.toJson(user))
      } recover {
        case _: AskTimeoutException => NotFound
      }
  }
.
@

    <p>
        Here we have declared the action itself.  It's an asynchronous action, meaning it returns a future.  The action
        also takes a parameter, the id of the user.  We'll see later how that parameter is passed to the action.
    </p>

    <p>
        As a first step we have defined a timeout.  In the code below that, we use the ask pattern, represented by the
        <code>?</code> operator, to ask the user meta data action for the user.  Akka will not let you ask for something
        without specifying a timeout, the <code>?</code> parameter takes an implicit timeout, so we've defined that to
        be two seconds.
    </p>

    <p>
        Having asked the actor for a user, we get back a future, and the first thing we do is map it to the type of
        <code>User</code>.  Then we map that to something that will generate our response, we're returning an
        <code>Ok</code> response, with the body being the user serialised to JSON.
    </p>

    <p>
        Finally, we also want to <code>recover</code> from a timeout.  We assume that if it timed out, it means the
        user could not be found.
    </p>

    <p>
        The last thing we need to do on the server side is declare how requests will be routed to this action.  We do
        this in the <code>routes</code> file:
    </p>

<<conf/routes>>=
9a
GET        /user/:email         controllers.UserController.get(email)
.
@

@@ sbt compile

    <p>
        You can see that we are defining a dynamic route with an <code>email</code> parameter, signalled by the colon
        before the parameter name.  Then we invoke the action we just created, passing that <code>email</code>
        parameter as the id of the user.
    </p>
</div>

<div>
    <h2>Consuming user data on the client side</h2>

    <p>
        Now that we've got the server side ready, we can write the client side code to consume the new action we just
        created.  Let's start with creating a new module,
        <code>app/assets/javascripts/services/userInfo.coffee</code>, that will
        make the AJAX call.  Although this module will be very simple, it's best practice to split out the making of
        AJAX calls from the business logic of your code, so you can easily mock and test.
    </p>

<<app/assets/javascripts/services/userInfo.coffee>>=
0a
define ["jquery"], ->
  {
    get: (email) ->
      $.getJSON("/user/" + email)
  }
.
@

    <p>
        Our <code>userInfo</code> module depends on <code>jquery</code>, and simply provides one method,
        <code>get</code>, which calls the action.  jQueries <code>getJSON</code> method returns a promise of the json,
        so we can consume that by attaching <code>then</code> or <code>done</code> callbacks to the returned promise.
    </p>

    <p>
        Now in <code>marker.coffee</code>, we want to
        use this service to look up the user info.  So we will add the <code>userInfo</code> module as a dependency.  If
        you're familiar with requireJS, you might notice that we're not using a relative path name here, this is because
        we are using path aliases that we configure elsewhere, this also makes mocking dependencies simpler, as it
        decouples modules from their implementation.
    </p>

<<app/assets/javascripts/map/marker.coffee>>=
4c
define ["leaflet", "markerRenderer", "userInfo"], (Leaflet, renderer, userInfo) ->
.
@

    <p>
        In the constructor of the <code>Marker</code> class, after attaching the popup to the marker, we want to bind
        to the click event of the marker so that we can update the popup with the users distance each time the user
        clicks on it:
    </p>

<<app/assets/javascripts/map/marker.coffee>>=
24c
        @marker.bindPopup(renderer.renderPopup(userId))

        @marker.on "click", =>
          userInfo.get(userId).done (user) =>
            @marker.getPopup()
              .setContent(renderer.renderPopup(userId, user.distance)).update()
.
@

    <p>
        And now we want to handle that additional distance parameter that we've passed to <code>renderPopup</code>,
        in <code>markerRenderer.coffee</code>:
    </p>

<<app/assets/javascripts/map/markerRenderer.coffee>>=
15,17c
  renderPopup: (userId, distance) ->
    popup = "<p><img src='http://www.gravatar.com/avatar/" +
      md5(userId.toLowerCase()) + "'/></p><p>" + escapeHtml(userId) + "</p>"
    if (distance)
      popup + "<p>Travelled: " + Math.floor(distance) + "m</p>"
    else
      popup
.
@

    <p>
        Finally, since we've defined the new <code>userInfo</code> module, we need to declare what the path for that
        module is.  This can be done in <code>app.coffee</code>:
    </p>

<<app/assets/javascripts/app.coffee>>=
13a
    userInfo: "./services/userInfo"
.
@

@@ sbt resources

    <p>
        And now we should be good to go, refresh your browser, and try clicking on a marker to see if the distance is
        rendered.  If you're looking at the bots walking around North Carolina, you might see that they are moving at
        hundreds of metres per second - these bots are designed to provide interesting data, not necessarily realistic
        data.
    </p>

</div>

<div>
    <h2>Scaling out</h2>

    <p>
        So now we've implemented something that works on a single node.  However, this application has been designed to
        scale to millions of users on hundreds of nodes - a feature that only works on a single node will not suffice.
    </p>
    
    <p>
        The system should also be resilient to system crashes and restarts. To address these issues we will make it
        persistent and distribute the actors over the backend nodes in the cluster.
    </p>

</div>
<div>
    <h2>Make UserMetaData event sourced</h2>

    <p>
        The <a href="#code/app/backend/UserMetaData.scala" class="shortcut">UserMetaData</a> actor that we developed
        previously holds the data for all users, which is obviously not scalable. Instead, let's rewrite the actor
        to represent the data for one single user. We will use 
        <a href="http://doc.akka.io/docs/akka/2.3.0/scala/persistence.html" target="_blank">Akka Persistence</a>
        to make it durable.   
    </p>
    
<<app/backend/UserMetaData.scala>>=
0,60c
package backend

import java.net.URLDecoder
import scala.concurrent.duration._
import akka.actor.PoisonPill
import akka.actor.Props
import akka.actor.ReceiveTimeout
import akka.contrib.pattern.ShardRegion
import akka.persistence.EventsourcedProcessor
import play.extras.geojson.LatLng

object UserMetaData {
  case class GetUser(id: String)
  case class User(id: String, distance: Double)
  case class UpdateUserPosition(id: String, position: LatLng)

  val props = Props[UserMetaData]

  sealed trait Event
  case class FirstObservation(position: LatLng) extends Event
  case class Moved(to: LatLng, distance: Double) extends Event

  private case class State(position: Option[LatLng], distance: Double) {
    def updated(evt: Event): State = evt match {
      case Moved(to, d)          => copy(distance = distance + d)
      case FirstObservation(pos) => copy(position = Some(pos))
    }
  }
}

class UserMetaData extends EventsourcedProcessor {

  import UserMetaData._

  val settings = Settings(context.system)
  val userId = URLDecoder.decode(self.path.name, "utf-8")
  private var state = State(None, 0.0)

  // passivate the entity when no activity
  context.setReceiveTimeout(30.seconds)

  override def receiveRecover: Receive = {
    case evt: Event => state = state.updated(evt)
  }

  override def receiveCommand: Receive = {
    case _: GetUser =>
      sender() ! User(userId, state.distance)

    case UpdateUserPosition(_, position) =>
      state match {
        case State(Some(lastPosition), _) =>
          val d = settings.GeoFunctions.distanceBetweenPoints(lastPosition, position)
          persist(Moved(position, d)) { evt =>
            state = state.updated(evt)
          }
        case State(None, _) =>
          persist(FirstObservation(position)) { evt =>
            state = state.updated(evt)
          }
      }
      
    case ReceiveTimeout => 
      context.parent ! ShardRegion.Passivate(stopMessage = PoisonPill)
  }
}
.
@

@@ sbt compile
    
    <p>
        Akka Persistence takes an event sourced approach and stores the changes that build up its current state.
        In this case the current position and the total distance is stored by the events
        <code>FirstObservation</code> and <code>Moved</code>.
    </p>
    
    <p>
        It is recommended to encapsulate the state in an immutable class as illustrated
        in the <code>UserMetaData.State</code> class. It knows how to create a new <code>State</code>
        instance when applying the changes represented by domain events. It is important that the
        state updates are free from side effect, because they are applied when the actor
        is recovered from the persisted events. See <code>receiveRecover</code>.
    </p>
</div>
<div>
    <h2>Add sharding</h2>    
    
    <p>
        <a href="http://doc.akka.io/docs/akka/2.3.0/contrib/cluster-sharding.html" target="_blank">Akka cluster Sharding</a>
        is useful when you need to distribute actors across several nodes in the cluster and want to
        be able to interact with them using their logical identifier, but without having to care about
        their physical location in the cluster, which might also change over time.
    </p>
    
    <p>
        To use the <code>UserMetaData</code> actor with cluster sharding we must be able to 
        extract the identifier from the messages and define a hash function for the identifier.
        The hash function is used to group actors into shards, potentially running on different
        nodes.
        Those functions can be defined in the companion object like this:
    </p>

<<app/backend/UserMetaData.scala>>=
13,15c
  sealed trait Command {
    def id: String
  }
  case class GetUser(id: String) extends Command
  case class User(id: String, distance: Double) extends Command
  case class UpdateUserPosition(id: String, position: LatLng) extends Command

  val idExtractor: ShardRegion.IdExtractor = {
    case cmd: Command => (cmd.id, cmd)
  }

  val shardResolver: ShardRegion.ShardResolver = msg => msg match {
    case cmd: Command => (math.abs(cmd.id.hashCode) % 100).toString
  }

  val shardName: String = "UserMetaData"
.
@

@@ sbt compile

    <p>
       To make the <code>UserMetaData</code> actors sharded in the cluster we need to register it to the 
       <code>ClusterSharding</code> extension. This must be done on all nodes in the cluster,
       but we do it slightly different on the nodes with <code>frontend</code> role compared to 
       <code>backend</code> because the actors must only be created on the backend nodes, and only
       proxied from frontend nodes. Add the following in <a href="#code/app/actors/Actors.scala" class="shortcut">Actors.scala</a> 
    </p>

<<app/actors/Actors.scala>>=
7a
import akka.contrib.pattern.ClusterSharding
.
@

<<app/actors/Actors.scala>>=
35,37c
    if (Cluster(system).selfRoles.exists(r => r.startsWith("backend"))) {
      system.actorOf(RegionManager.props(), "regionManager")
      
      ClusterSharding(system).start(
        typeName = UserMetaData.shardName,
        entryProps = Some(UserMetaData.props),
        idExtractor = UserMetaData.idExtractor,
        shardResolver = UserMetaData.shardResolver)
    } else {
      ClusterSharding(system).start(
        typeName = UserMetaData.shardName,
        entryProps = None,
        idExtractor = UserMetaData.idExtractor,
        shardResolver = UserMetaData.shardResolver)
    }
.
@

<<app/actors/Actors.scala>>=
61c
  private lazy val userMetaData = ClusterSharding(system).shardRegion(UserMetaData.shardName)
.
@


@@ sbt compile

    <p>
        And corresponding in <a href="#code/app/backend/Main.scala" class="shortcut">Main.scala</a>:
    </p>

<<app/backend/Main.scala>>=
6a
import akka.contrib.pattern.ClusterSharding
.
@

<<app/backend/Main.scala>>=
27a

      ClusterSharding(system).start(
        typeName = UserMetaData.shardName,
        entryProps = Some(UserMetaData.props),
        idExtractor = UserMetaData.idExtractor,
        shardResolver = UserMetaData.shardResolver)
.
@

<<app/backend/Main.scala>>=    
38c

      ClusterSharding(system).start(
        typeName = UserMetaData.shardName,
        entryProps = None,
        idExtractor = UserMetaData.idExtractor,
        shardResolver = UserMetaData.shardResolver)
      val userMetaData = ClusterSharding(system).shardRegion(UserMetaData.shardName)
.
@

</div>
<div>
    <h2>Setup the journal</h2>

@@ sbt compile

    <p>
        When using Akka Persistence in a cluster we need a journal that is replicated or accessible from all nodes.
        In this sample we will use a 
        <a href="http://doc.akka.io/docs/akka/2.3.0/scala/persistence.html#Shared_LevelDB_journal" target="_blank">shared LevelDB journal</a>
        running on the node with port 2551. This is a single point of failure, and should not be used in production. 
        A real system would use a <a href="http://akka.io/community/" target="_blank">distributed journal</a>.
    </p>
    
    <p>
        Add the configuration for the journal:
    </p>

<<conf/application.conf>>= 
93a

  persistence {
    journal.plugin = "akka.persistence.journal.leveldb-shared"
    journal.leveldb-shared.store {
      # DO NOT USE 'native = off' IN PRODUCTION !!!
      native = off
      dir = "target/shared-journal"
    }
    snapshot-store.local.dir = "target/snapshots"
  }
.
@

    <p>
        Add the file <a href="#code/app/backend/SharedJournalHelper.scala" class="shortcut">app/backend/SharedJournalHelper.scala</a>
        with the following content:

<<app/backend/SharedJournalHelper.scala>>=
0a
package backend

import scala.concurrent.duration._
import akka.actor.ActorIdentity
import akka.actor.ActorPath
import akka.actor.ActorSystem
import akka.actor.Identify
import akka.actor.Props
import akka.pattern.ask
import akka.persistence.journal.leveldb.SharedLeveldbJournal
import akka.persistence.journal.leveldb.SharedLeveldbStore
import akka.util.Timeout
import akka.cluster.Cluster

object SharedJournalHelper {

  def startupSharedJournal(system: ActorSystem): Unit = {
    // Start the shared journal one one node (don't crash this SPOF)
    // This will not be needed with a distributed journal
    val storePort = 2552
    if (Cluster(system).selfAddress.port.get == storePort)
      system.actorOf(Props[SharedLeveldbStore], "store")
    // register the shared journal
    import system.dispatcher
    implicit val timeout = Timeout(10.seconds)
    val storePath = ActorPath.fromString(s"akka.tcp://${system.name}@127.0.0.1:$storePort/user/store")
    val f = (system.actorSelection(storePath) ? Identify(None))
    f.onSuccess {
      case ActorIdentity(_, Some(ref)) => SharedLeveldbJournal.setStore(ref, system)
      case _ =>
        system.log.error("Shared journal not started at {}", storePath)
        system.shutdown()
    }
    f.onFailure {
      case _ =>
        system.log.error("Lookup of shared journal at {} timed out", storePath)
        system.shutdown()
    }
  }

}
.
@

    <p>
        Initialize the shared journal in <a href="#code/app/actors/Actors.scala" class="shortcut">Actors.scala</a>
    </p>

<<app/actors/Actors.scala>>=
34a

    // This will not be needed with a distributed journal
    SharedJournalHelper.startupSharedJournal(system)

.
@

    <p>
        And corresponding in <a href="#code/app/backend/Main.scala" class="shortcut">Main.scala</a>:
    </p>

<<app/backend/Main.scala>>=
25a
    // This will not be needed with a distributed journal
    SharedJournalHelper.startupSharedJournal(system)

.
@

@@ sbt compile

</div>
<div>
    <h2>Run it again</h2>

    <p>
        We have now added scalability and resilience to the new user meta data feature. Try it again, by refreshing your browser
        at <a href="http://localhost:9000" target="_blank">http://localhost:9000</a>.
    </p>
        
    <p>
        The files of the shared journal are saved in the target directory and when you restart
        the application the state is recovered. You can clean the state with:
    </p>

<pre><code>
&lt;path to activator dir&gt;/activator clean
</code></pre>

</div>

<div>
    <h2>Learn more about reactive design</h2>
    
    <p>
      Essential characteristic of a reactive application:
    </p>
    <ul>
      <li>react to events - the event-driven nature enables the following qualities</li>
      <li>react to load - focus on scalability by avoiding contention on shared resources</li>
      <li>react to failure - build resilient systems with the ability to recover at all levels</li>
      <li>react to users - honor response time guarantees regardless of load</li>
    </ul>
    
    <p>
      Read more about how to build reactive applications in the 
      <a href="http://www.reactivemanifesto.org/" target="_blank"><b>Reactive Manifesto</b></a>.
    </p>
    
</div>

</body>
</html>
